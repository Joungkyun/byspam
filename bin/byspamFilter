#!@PERLPATH@
#
# By SPAM main code.
# This package code follows BPL License
# JoungKyun Kim <http://www.oops.org>
#
# $Id: byspamFilter,v 1.19 2004-11-30 19:24:38 oops Exp $
#
use lib '@includedir@';
my $conf = "@confdir@/byspam.conf";

use strict;

use Byspam::Getopt;
use Byspam::Common;
use Byspam::Parse;
use Byspam::Mail;

# declaration global variable on configuration file
use vars qw ($version  $allows $ignore $filterIframe $filterTag $trashPeriod);
use vars qw ($nobody $noheader $charset @basics $_filtered $debug $verbose);
use vars qw ($binDir  $confdir $filterDir $includeDir $perlpath);

# init global variables
$version      = "";
$filterIframe = 0;
$filterTag    = 1;
$nobody       = 1;
$noheader     = 1;

# declaration variables

# common variables
my $cm;
my $ps;
my $o;
my $ov;

# option variable;
my $opt      = "";
my $_file    = "";

# area variables
my @gets     = ();
my @ctype    = ();
my @files    = ();
my @mailText = ();

my $newline  = "";
my $mail;
my $header;
my $body;

# common filter variables
my $_ftarget = "";

# check result variables
my $spam     = 0;
my $fil      = "";
my $ispam    = 0;
my $nospam   = 0;

# get argument on shell
my $_argc    = $#ARGV;
my @_argv    = @ARGV;

$verbose  = 0;
$debug    = 0;

# create reference Common
$cm = new Byspam::Common;

# get configuration file
if ( ! -f "$conf" ) {
	$cm->printError (
			"\n" .
			"    Configuration file missing.\n" .
			"    Check \"$conf\" file\n" .
			"\n"
	);
	exit 1;
}

require $conf;

if ( ! $charset ) {
	$charset = $ENV{"LANG"};
	CHARSET: { 
	    ( $charset =~ m/^ko/i ) and $charset = "EUC-KR", last CHARSET;
	    ( $charset =~ m/^utf/i ) and $charset = "UTF-8", last CHARSET;
	    $charset = "";
	}
}

# create reference Getopt
$o = new Byspam::Getopt;
$ov = $o->{_var};

# match long option whit short option
$ov->{longopt} = {
	'destination' => 'd',
	'pipe'        => 'p',
	'verbose'     => 'v',
	'help'        => 'h'
};

while ( 1 ) {
	$opt = $o->getopt ("d:hvp", $_argc + 1, @_argv);
	last if ( ! $opt );

	SWITCH: {
		( $opt eq "d" ) and do {
			if ( ! $ov->{optarg} ) {
				printHelp ();
			}
			$_file = $ov->{optarg};
			$debug   = 1;
			$newline = "\n";
			last SWITCH;
		};
		( $opt eq "p" ) and do {
			$debug   = 1;
			$newline = "\n";
			last SWITCH;
		};
		( $opt eq "v" ) and do {
			$verbose = 1;
			$debug   = 1;
			$newline = "\n";
			last SWITCH;
		};

		printHelp ();
	}
}

printHelp () if ( $ov->{getopt_err} or $ov->{optcno} );

# get filtering data
foreach ( @basics ) {
	@gets = split (/:/, $_);
	push @ctype, $gets[0];
	push @files, $gets[1];
}

# import original mail format
if ( $_file ) {
	if ( ! -f $_file ) {
		$cm->printError ("Error: Can't found $_file\n");
		exit 1;
	}

	@mailText = $cm->getContext_rr ($_file);
} else {
	@mailText = <STDIN>;
}

# ------------------------------------------------------------------------------
# parsing mail
# ------------------------------------------------------------------------------

# original mail format parsing
$mail = Byspam::Mail->new (\@mailText);
$ps = new Byspam::Parse;

$spam = 1, $fil = "No Head", goto CHECKEND if ( $noheader && ! $mail->{_header} );
$spam = 1, $fil = "No Body", goto CHECKEND if ( $nobody && ! $mail->{_body} );

# header parsing
$header = $ps->getHeader ($mail->{_header});

# body parsing
$body = $ps->getBody ($mail);


# ------------------------------------------------------------------------------
# filter mail
# ------------------------------------------------------------------------------

#
# check EXTRA unparsing header and body
#

$_ftarget = $header . "\n\n" . $mail->{_body};
if ( checkFilter ($_ftarget, "filter-extra") ) {
    $spam     = 1;
    $fil      = "Extra";
    
	printMessage ($fil, $_filtered);
	$_ftarget = $header . "\n\n" . $body;
    
    goto CHECKALLOW;
}

#
# check each part
#

my $checkNo = @basics;
my $i       = 0;
my $_regs   = "";

for ( $i=0; $i<$checkNo; $i++ ) {
	next if ( ! -f "$filterDir/$files[$i]" );
	$fil = $ctype[$i];
	next if ( $fil eq "Extra" );

	PART: {
		( $fil eq "Body" ) and do {
			if ( $filterTag && $cm->noContentCheck ($body) ) {
				$spam = 1;
				printMessage ($fil, $_filtered);
				goto CHECKALLOW;
			}

			$_ftarget = $body;
			$_regs = "|<ifrmae" if ( $filterIframe );
			last PART;
		};

		$_ftarget = $ps->parseHeader ($mail->header ($fil));
		$_ftarget .= $ps->parseHeader ($mail->header ("Reply-To")) if ($fil eq "From");
		$_regs = "";
	}

	$_ftarget = $cm->trim ($_ftarget);
	$spam = checkFilter ($_ftarget, $files[$i], $_regs);

	if ( $spam ) {
		printMessage ($fil, $_filtered);
		goto CHECKALLOW;
	}
}

goto CHECKEND if ( ! $spam );

CHECKALLOW:
if ( $spam && $fil ) {
	$nospam = checkFilter ($_ftarget, $allows);

	if ( $nospam ) {
		printMessage ($fil, $_filtered, "Allow");
		goto CHECKIGNORE;
	}

	goto CHECKEND;
}

CHECKIGNORE:
if ( $spam && $nospam && $fil ) {
	$ispam = checkFilter ($_ftarget, $ignore);

	if ( $ispam ) {
		printMessage ($fil, $_filtered, "Ignore");
		$nospam = 0;
	}
}

#
# Print Result
#
# spam = 1 is spam
# nodpam = 1 not spam
# ispam = 1 ignore nospam
#
# if not spam, no message and return code 0
# if spam, print spam, print part message and return code 405
#
#
CHECKEND:
if ( $spam && ! $nospam ) {
	print "RESULT: " if ( $debug );
	printf "%s%s", $fil, $newline;
	exit 405;
}


#
# Byspam function
#

sub checkFilter {
	my ($_text, $_filter, $_addreg ) = @_;
	my $_reg;
	my $_f;

	$_filtered = "";

	$_f = "$filterDir/$_filter";
	$_reg = $cm->filterText ( $_f );
	$_reg .= $_addreg if ( $_addreg );
		
	if ( $_reg ) {
		if ( $_text =~ /($_reg)/i ) {
			$_filtered = $1;
			return 1;
		}
	}

	return 0;
}

sub printMessage {
	my ( $_p, $_f, $_m ) = @_;

	if ( $main::debug ) {
		if ( $_m ) {
			printf "Ignore %s filtered by %s", $fil, $_m;
		} else {
			printf "Checked By %s", $fil;
		}
		printf " => \"$_f\"" if ( $main::verbose );
		printf "\n";
	}
}

# print help message and save directory
#
sub printHelp {
	my $lc;
	my $USAGES;

	$lc = $main::charset;
	my @helps = ();
	if( $lc eq "EUC-KR" ) {
		$USAGES = "사용법";
		@helps = (
				  "현재 메세지를 출력",
				  "인자로 넘긴 메일형식의 절대경로 파일을 체크 [ 디버그 모드 ]",
				  "메일 형식을 파이프로 넘기는 형식",
				  "메일 형식을 파이프로 넘기는 형식 [ 디버그 모드 ]"
		);
	} else {
		$USAGES = "USAGE";
		@helps = (
				  "print this message",
				  "debug mode with file(absolte path) of mail form",
				  "put mail form with pipe",
				  "debug mode with put mail form with pipe",
		);
	}

	$cm->printError (
			"\n$USAGES : \n" .
			"    byspamFilter [ -h --help ]\n" .
			"          => ${helps[0]}\n\n" .
			"    byspamFilter -d mail_form_file_pull_path \n" .
			"          => ${helps[1]}\n\n" .
			"    cat mail_form_file | byspamFilter \n" .
			"          => ${helps[2]}\n\n" .
			"    cat mail_form_file | byspamFilter -p \n" .
			"          => ${helps[3]}\n\n"
	);

    exit 1;
}

exit 0;

#
# Local variables:
# tab-width: 4
# c-basic-offset: 4
# End:
# vim600: noet sw=4 ts=4 fdm=marker
# vim<600: noet sw=4 ts=4
#
